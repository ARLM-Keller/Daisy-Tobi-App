[[TOC]]

= Tobi Development Process =

== Overview ==

A "waterfall-like" development program tends to be monolithic and immutable, resulting in high resistance to change. Instead, we are using an incremental process whereby each iteration adds value to the final product deliverable. We also operate within the confines of an agile management method, in order to maximize the interactions between ourselves and our development partners. This should greatly reduce the risk of delay or a situation where the deliverable does not match expectations.

Major milestones are set at 3 months intervals to produce concrete product deliverables ("public releases"). Each milestone is completed in 3 short (1 month) iterations, to enable frequent progress tracking and intermediary reporting ("internal releases").

One of our goals is to minimize the management overhead while maximizing the usable output. This is why we have chosen the lightweight and agile development process called "Scrum"[[FootNote(http://www.controlchaos.com)]]^,^[[FootNote(http://en.wikipedia.org/wiki/Scrum_(development))]].

== Thoughts, Drafting Things Out ==

Keeping things simple is important. Developers can quickly get scared by over-complicated words and procedures. However, the practices that Scrum advocates are based on common-sense, and the Trac environment should help us implementing a Scrum process in a user-friendly manner. Our goal is to implement a process that "Gets Things Done"[tm](C), rather than introducing unnecessary management work.

Here's how we could make it work for Tobi:

Once we complete the Requirements Gathering process, we deliver a formal Product Backlog definition of the Tobi application, stored as Tickets in the Trac Issue Tracker + a central Wiki page. That's our ultimate goal, our Holy Grail. It's not immutable, but it should be pretty stable for at least the first phase of the project (~2 years).

Note:
This specification is basically what the DAISY consortium is promoting when it does fund-raising or when it approaches potential collaborators.

Then, we plan iteration #1 by allocating Tickets to Sprint Backlog #1. For that, we can annotate Tickets by using custom or existing fields (milestone, component, version).

Note:
In Scrum, cost estimates for a Ticket are given in traditional time units, or any other abstract scale that meets our requirements (we're a small team, so we can work this out). The built-in fields "time-estimated", "time-spent", "time-remaining" can be used to track this information. We can then use custom Queries / Reports to display the content of one Sprint in terms of Open and Closed Tickets.

We maintain one Wiki page per Sprint, including minutes for the Daily Scrum and final Retrospective meeting. This way, a "spine" Wiki page would basically allow us to track progress globally for all completed iterations, throughout the project lifespan.

Note:
Remember, the unit in the Trac "Roadmap" section is not a single Sprint, but a high-level Milestone. We decided that these were going to be 3-month "phases" (Trac just calls them Milestones), at the end of which a public deliverable is due. So the "Roadmap" section is for managers / fund-raisers, whereas the "Sprint-Spine" Wiki page would be more for developers and the Scrum Master (i.e. Markus/Daniel).

The goal is to "empty" the Sprint Backlog at the end of an iteration, but if this fails (optimistic cost/time estimate, unexpected impediments, etc.), the remaining open issues in the current Backlog #n get shifted to #n+1.

This planning process happens during the Retrospective meeting, where the previous Sprint is formally validated and the next one is agreed-on with the Product Owner (i.e. George/Hiroshi). The goal of course, is to avoid making mistakes by refining the process so that later iterations can be planned correctly.

== Using Trac Efficiently ==

Using Trac in the context of an agile/Scrum development process is relatively new to us.

There are Trac plugins to help with iteration planning, tracking and reporting (i.e. "burndown" chart). However, the default set of plugins provided by the CVS-Dude configuration should be sufficient (the most useful of which is the "time-estimation" plugin that adds time/cost fields on tickets and nice reporting graphics for milestones).

 * [http://www.agile42.com/cms/pages/download/]
 * [http://trac-hacks.org/wiki/ScrumBurndownPlugin]
 * [http://trac-hacks.org/wiki/ScrumPlugin]
 * [http://jeffsutherland.com/scrum/2007/03/scrum-burndown-using-trac.html]
 * This wiki (also a CVS-Dude Trac instance) provides interesting information about their project's Scrum implementation (process state-chart, custom ticket fields and queries for iteration tracking and planning): [https://clearcanvas-trac.cvsdude.com/source/wiki/Developers]

[[FootNote]]

