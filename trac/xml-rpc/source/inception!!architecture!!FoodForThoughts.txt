= IoC an DI =

---
Acronyms:

IoC = "Inversion of Control"
DI = "Dependency Injection"
---

We're currently using WPF ("Windows Presentation Foundation") as an implementation technology for Tobi. It provides true separation of concerns (e.g. declarative UI vs coded business logic) and enables a clean architecture for the integration of the Urakawa SDK (using built-in data-binding, commands and events).

One of our top-level requirements is that Tobi needs to provide a rich extensibility framework so that plugins can be developed by third-party contributors. The ideal would be to reach the kind of flexibility seen in the Eclipse RCP (Rich Client Platform) or with the Mozilla extensions/add-ons framework.

In order to enable modularity (with dynamic-loading capability and runtime dependency resolution) we are using an architecture called CAG ("Composite Application Guidance"), which has its own reference library implementation (CAL). The library comes with a default Microsoft-written IoC container called "Unity Application Block" (in short: "Unity"), which relies on DI like most (all?) other IoC containers out-there.

The design patterns implemented in CAL facilitate cross-cutting services (i.e. logging, progress-jobs, localization, etc.), and also make it a lot easier to unit-test a large code-base by configuring the container with mock objects of specific lifetimes.

It's not as powerful as "OSGi", but we're not far-off (OSGi is Java-centric anyway). CAG/CAL is in fact simpler with its bootstrapper design and its host application concept.

Regarding IoC, I've been reading about other containers, such as "Castle Windsor", "PicoContainer" and "StructureMap". I've also looked into "Spring", knowing that the Online-Pipeline (Pipe-online?) is heading that way (Romain, am I right?).

-- NOTE: the one thing I have noticed is that Unity does not allow AOP (Aspect Oriented Programming), as it has no support for the Interceptor pattern (pre/post method weaving at runtime). I don't really care for AOP, but knowing that Spring enables such development paradigm, I wanted to know whether Romain found any use for it ? --

What I've discovered is that the terms "IoC" and "DI" are often miss-used: "IoC" is a principle, "IoC container" is a design pattern which mostly relies on the "DI" variants as an implementation mechanism for the IoC principle (DI via Constructor, Property, Field, Method, Interface, etc.). The terms are often swapped thus the "DI container" expression. I think this is well-explained here:

http://www.castleproject.org/container/documentation/v1rc3/concepts/ioc.html

Martin Fowler is nearly always referenced but his explanation actually does not get the point, or at least is miss-leading:

http://martinfowler.com/articles/injection.html

Here is why:

http://www.betaversion.org/~stefano/linotype/news/38/

Next, here's a bunch of references which I have found pretty useful:

PicoContainer:

http://www.picocontainer.org/inversion-of-control.html

StructureMap:

http://structuremap.sourceforge.net/Concepts.htm

The Spring framework (with the Java "Beans" naming convention):

http://static.springframework.org/spring/docs/2.0.x/reference/beans.html

http://static.springframework.org/spring/docs/2.0.x/reference/introduction.html

The Spring.NET (C#) container:

http://www.springframework.net/doc-latest/reference/html/quickstarts.html

Castle Windsor (based on MicroKernel):

http://www.castleproject.org/container/index.html

Unity Application Block:

http://www.codeplex.com/unity

Ninject:

http://ninject.org/

Composite WPF Applications:

http://msdn.microsoft.com/en-us/library/cc707906.aspx
