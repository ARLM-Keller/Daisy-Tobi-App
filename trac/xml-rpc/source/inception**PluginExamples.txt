= Tobi Plugin Examples =
This page contains descriptions of a series of developer-perspective examples of functionality/features that are added through a plugin/SOA framework. 

We need to aim for plugins being contributed using any of these patterns (in any combination):

 '''Plugins that replace existing functionality'''::
  Example: replace the existing VU-meter
 '''Plugins that refine existing functionality''':: 
  Equals the refinement of an existing plugin.
  Example: add a new "merge sections" method to a tree-based TOC Editor plugin
 '''Plugins that provide entirely new functionality'''::
  Example: add a noise reduction feature to an audio editor

== Adding a project annotation feature ==
 ''The developer will want to:''

 * Introduce "add anotation", "delete anotation" and "view annotation" actions, with activators (buttons) appearing in 1-n already existing(widgets) toolbars/menus;
 * When the add or view actions are invoked, pop a dialog that allows entering textual or audiotorial data;
 * When this dialog is closed, add this as a custom AnnotationProperty in the SDK tree;
 * Add a view that lists existing annotations and and allows navigating to presentation position, allows removing select annotations;
 * Show existing annotations as lines with a custom color in existing wave form view(s);
 * Add the add/delete/view actions to the context menu of the wave form view;
 * Persist the annotations at save project time;
 * Reinstantiate the annotations at project load time;
 * Add an "Export Annotations as Zed Bookmark File" action appearing in application main menu bar File;

== Adding a physical-level audio manipulation feature ==
(think noise reduction)
 ''The developer will want to:''

 * Be able to define a wizard, and give access to it in existing menus. Used to noise-reduce sets of files in one batch operation;
 * Get access to current selection in a wave view;
 * Get access to action population of local menus/context menus in relevant views (where a shortcut "noise reduce current selection" appears);
 * Get access to assett management to get/replace wave assets

== Adding support for the remote control Sony RCS-2 mkIII ==
 ''The developer will want to:''
 * Append a new tab "remote control setup" to the existing configuration dialog;
 * Get read access to application state (recording, playing, paused, etc);
 * Get access to application state modification (start recording, stop recording, play, etc);
 * Get access to presentation (SDK tree navigation) features (next, previous, first, last, ff, rew)

== Adding support for a new Save As option ==
 ''The developer will want to:''
 * Append a new Save As XYZ to the existing File menu item in the main application menu;
 * Be able to pop an options dialog/options wizard that is invoked by the save as XYZ action;
 * Get access to the SDK data tree when serializing.

== "Quick-Fix" ==

We talked about the concept of "intentions" or "quick-fixes", which is a User-Interface design that streamlines the document validation process (in the broader sense, not XML-Schema sense).

So, at authoring time, issues are highlighted inline (i.e. errors/warnings with a red/orange squiggle under a text portion or in the gutter of the text editor), and the user can request an in-context popup menu (or any non-intrusive GUI metaphor) that contains one or more possible fixes (very much like a spell-checker).

Now, this list of proposed fixes is totally extensible via plugins. For example, let's take the following use-case that was recently sent on the Microsoft-Save-As-DAISY-XML internal mailing-list:

> The presence of empty p elements may be the intention of the author to
> provide some white space. In addition, when documents are "round tripped" in
> a future release, this white space would be preserved.
>
> The message surrounding the introduction of empty p elements  between two
> headings of the same level should inform the author that this is normally
> viewed as a authoring error. The introduction of the empty paragraph is to
> permit a successful, valid export.

Well, in Tobi, we would expose a very simple extension point (i.e. API) for third-party developers, and I think a very simple macro-like language (preferably in declarative XML, like ANT makefiles) to let programmers specify a "quick-fix".

The example mentioned above is about treating empty paragraphs. It's not a validation error per-say, so it's more like a warning for breaking good-practice. Here's how it could look like (without the XML tags):

-- QUICK-FIX --

Title (string):
"Fix empty <p> elements."

Decription (string):
"Proposes alternative content for empty paragraphs."

Type (enum Warning|Error):
"Warning"

Trigger-content (PERL-compatible regular expression):
"<p>[ |\n|\t]*</p>"

-- Fix[1]

Title (string):
"Delete."

Description (string):
"Removes the empty paragraph."

Action (MACRO):
"clear()"

-- Fix[2]

Title (string):
"Replace with line break."

Description (string):
"Replaces the empty paragraph with a double line break."

Action (MACRO):
"replace_with('<br/><br/>')"

-- Fix[3]

Title (string):
"Replace with horizontal line."

Description (string):
"Replaces the empty paragraph with a horizontal line."

Action (MACRO):
"replace_with('<hr/>')"

---------------


Remarks:

The above fixes are for illustrative purposes only, I have not thought about the DTBook grammar at all.

A nice feature would be to prompt the user with something like "apply to all".

I think that the "Trigger-content" field would better NOT be a regexp. Something like XPath would be much better, especially for context-aware structural issues. Anyway, it's just a proof-of-concept.


I found a pretty good example of a rich application (the generic XML editor "Syntext Serna") which exposes an C++ and Python API for allowing third-party customizations, and of course the definition of plugins.

I have added some screenshots here:

http://daisy-trac.cvsdude.com/tobi/wiki/inception/ExistingSoftware#genericXMLediting:tagsandTOCSyntexSerna

It's an interesting example because things are sufficiently simple to be easily documented, and therefore easily adopted by developers:

http://docs.syntext.com/sapi_guide/sg.html#phases-plugin-init

http://docs.syntext.com/sapi_guide/sg.html#plugin-loading

The "SPD" format is pretty much what I have in mind when talking about declarative UI (for the simple use-cases, of course. Not for plugins that define or enrich complex graphical user-interfaces):

http://docs.syntext.com/sapi_guide/sg.html#hello-spd

http://docs.syntext.com/sapi_guide/sg.html#custom-dialog-layout

